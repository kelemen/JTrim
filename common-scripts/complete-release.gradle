import org.eclipse.jgit.api.*;
import org.eclipse.jgit.storage.file.*;

buildscript {
    repositories { mavenCentral() }
    dependencies {
        classpath 'org.eclipse.jgit:org.eclipse.jgit:2.0.0.201206130900-r'
        classpath 'commons-io:commons-io:2.4'
    }
}

private String incVersion(String version) {
    int sepIndex = version.lastIndexOf('.');
    String prefix = version.substring(0, sepIndex);
    int patchVersion = Integer.parseInt(version.substring(sepIndex + 1, version.length()));
    return prefix + '.' + (patchVersion + 1);
}

private String setNextVersion() {
    String nextVersion = incVersion(versionBase);
    java.nio.file.Files.write(rootProject.file('version.txt').toPath(), nextVersion.getBytes('UTF-8'));
    return nextVersion;
}

def releaseTask = project.task('release');
gradle.projectsEvaluated {
    def releaseProjectTasks = new LinkedList();
    allprojects { p ->
        def uploadTask = p.tasks.findByName('releaseProject');
        if (uploadTask != null) {
            releaseProjectTasks.add(uploadTask);
        }
    }

    releaseTask.dependsOn(releaseProjectTasks);
    releaseTask.doLast {
        def gitRepo = new FileRepository(rootProject.file('.git'));
        try {
            def git = new Git(gitRepo);

            def statusCommand = git.status();
            def status = statusCommand.call();

            if (!status.untracked.isEmpty()) {
                throw new RuntimeException("There are untracked files in the repository and so the release cannot be completed. Revert the changes already done manually.");
            }
            if (!status.isClean()) {
                throw new RuntimeException("The repository is not clean (contains uncommited changes) and so the release cannot be completed. Revert the changes already done manually.");
            }

            def tagCommand = git.tag();
            tagCommand.name = "v${project.version}".toString();
            tagCommand.message = "Release of JTrim ${project.version}".toString();
            tagCommand.call();

            String nextVersion = setNextVersion();

            def addCommand = git.add();
            addCommand.addFilepattern('version.txt');
            addCommand.update = true;
            addCommand.call();

            def commitCommand = git.commit();
            commitCommand.message = "Set the version to ${nextVersion}".toString();
            commitCommand.call();
        } finally {
            gitRepo.close();
        }
        println "New Release: ${project.group}:${project.name}:${project.version}";
    }
}
