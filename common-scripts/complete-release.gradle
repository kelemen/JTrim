import org.eclipse.jgit.api.*;
import org.eclipse.jgit.storage.file.*;

buildscript {
    repositories { mavenCentral() }
    dependencies {
        classpath 'org.eclipse.jgit:org.eclipse.jgit:2.0.0.201206130900-r'
        classpath 'commons-io:commons-io:2.4'
    }
}

private String incVersion(String version) {
    int sepIndex = version.lastIndexOf('.');
    String prefix = version.substring(0, sepIndex);
    int patchVersion = Integer.parseInt(version.substring(sepIndex + 1, version.length()));
    return prefix + '.' + (patchVersion + 1);
}

def releaseTask = project.task('release');
gradle.projectsEvaluated {
    def releaseProjectTasks = new LinkedList();
    allprojects { p ->
        def uploadTask = p.tasks.findByName('releaseProject');
        if (uploadTask != null) {
            releaseProjectTasks.add(uploadTask);
        }
    }

    releaseTask.dependsOn(releaseProjectTasks);
    releaseTask.doLast {
        String nextVersion = incVersion(versionBase);
        java.nio.file.Files.write(rootProject.file('version.txt').toPath(), nextVersion.getBytes('UTF-8'));

        def gitRepo = new FileRepository(rootProject.file('.git'));
        try {
            def git = new Git(gitRepo);

            def addCommand = git.add();
            addCommand.addFilepattern('version.txt');
            addCommand.update = true;
            addCommand.call();

            def commitCommand = git.commit();
            commitCommand.message = "Set the version to ${nextVersion}".toString();
            commitCommand.call();
        } finally {
            gitRepo.close();
        }
        println "New Release: ${project.group}:${project.name}:${project.version}";
    }
}
